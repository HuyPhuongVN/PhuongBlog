<!DOCTYPE html><html lang="en-us"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Chương 6: Kỹ thuật đa tiến trình và tuần tự hoá... Ứng dụng mạng - Huy Phuong&#x27;s Blog</title><meta name="description" content="CHÀO! Trong bài học hôm nay, chúng ta sẽ nói về serialization và deserialization trong Java. Chúng ta sẽ bắt đầu với một ví dụ đơn giản. Hãy tưởng tượng rằng bạn là một nhà phát triển trò chơi máy tính. Nếu bạn lớn lên&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-6-ky-thuat-da-tien-trinh-va-tuan-tu-hoa-ung-dung-mang/"><link rel="alternate" type="application/atom+xml" href="https://github.com/HuyPhuongVN/PhuongBlog.git/feed.xml"><link rel="alternate" type="application/json" href="https://github.com/HuyPhuongVN/PhuongBlog.git/feed.json"><meta property="og:title" content="Chương 6: Kỹ thuật đa tiến trình và tuần tự hoá... Ứng dụng mạng"><meta property="og:image" content="https://github.com/HuyPhuongVN/PhuongBlog.git/media/website/383700-final.jpg"><meta property="og:image:width" content="1920"><meta property="og:image:height" content="1080"><meta property="og:site_name" content="Huy Phuong's Blog"><meta property="og:description" content="CHÀO! Trong bài học hôm nay, chúng ta sẽ nói về serialization và deserialization trong Java. Chúng ta sẽ bắt đầu với một ví dụ đơn giản. Hãy tưởng tượng rằng bạn là một nhà phát triển trò chơi máy tính. Nếu bạn lớn lên&hellip;"><meta property="og:url" content="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-6-ky-thuat-da-tien-trinh-va-tuan-tu-hoa-ung-dung-mang/"><meta property="og:type" content="article"><link rel="stylesheet" href="https://github.com/HuyPhuongVN/PhuongBlog.git/assets/css/style.css?v=859f8aff2fa06797deac8baca34eab8b"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-6-ky-thuat-da-tien-trinh-va-tuan-tu-hoa-ung-dung-mang/"},"headline":"Chương 6: Kỹ thuật đa tiến trình và tuần tự hoá... Ứng dụng mạng","datePublished":"2024-12-27T19:33+07:00","dateModified":"2024-12-27T19:33+07:00","description":"CHÀO! Trong bài học hôm nay, chúng ta sẽ nói về serialization và deserialization trong Java. Chúng ta sẽ bắt đầu với một ví dụ đơn giản. Hãy tưởng tượng rằng bạn là một nhà phát triển trò chơi máy tính. Nếu bạn lớn lên&hellip;","author":{"@type":"Person","name":"Trần Huy Phương","url":"https://github.com/HuyPhuongVN/PhuongBlog.git/rainblog/huyphuong/"},"publisher":{"@type":"Organization","name":"Trần Huy Phương"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><header class="top js-header"><a class="logo" href="https://github.com/HuyPhuongVN/PhuongBlog.git/">Huy Phuong&#x27;s Blog</a><div class="search"><div class="search__overlay js-search-overlay"><div class="wrapper search__overlay-inner"></div></div><button class="search__btn btn--icon js-search-btn" aria-label="Search"><svg height="18" width="18" role="presentation" focusable="false"><use xlink:href="https://github.com/HuyPhuongVN/PhuongBlog.git/assets/svg/svg-map.svg#search"/></svg></button></div></header><main class="post"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>Chương 6: Kỹ thuật đa tiến trình và tuần tự hoá... Ứng dụng mạng</h1><div class="feed__meta content__meta"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/rainblog/huyphuong/" class="feed__author">Trần Huy Phương</a> <time datetime="2024-12-27T19:33" class="feed__date">December 27, 2024</time></div></div></header></div><div class="entry-wrapper content__entry"><p>CHÀO! Trong bài học hôm nay, chúng ta sẽ nói về serialization và deserialization trong Java. Chúng ta sẽ bắt đầu với một ví dụ đơn giản. Hãy tưởng tượng rằng bạn là một nhà phát triển trò chơi máy tính. Nếu bạn lớn lên trong những năm 90 và nhớ về máy chơi game thời đó, bạn có thể biết rằng chúng thiếu một thứ mà chúng ta coi là hiển nhiên ngày nay — khả năng lưu và tải trò chơi :) Nếu không, hãy tưởng tượng điều đó!<img loading="lazy" src="https://cdn.codegym.cc/images/article/a9b24d61-3a21-488a-a2b7-d97bee062ce4/800.jpeg" alt="Tuần tự hóa và giải tuần tự hóa trong Java - 1" data-id="a9b24d61-3a21-488a-a2b7-d97bee062ce4" data-max-width="850" data-is-external-image="true">Tôi sợ rằng một trò chơi ngày nay không có những khả năng này sẽ bị diệt vong! Dù sao thì, 'lưu' và 'tải' một trò chơi nghĩa là gì? Chà, chúng tôi hiểu ý nghĩa hàng ngày: chúng tôi muốn tiếp tục trò chơi từ nơi chúng tôi đã dừng lại. Để làm điều này, chúng tôi tạo một "điểm kiểm tra" nhất định mà chúng tôi sử dụng sau này để tải trò chơi. Nhưng điều đó có ý nghĩa gì đối với một lập trình viên hơn là một game thủ bình thường? Câu trả lời rất đơn giản: chúng tôi lưu trạng thái của chương trình. Giả sử bạn đang chơi trò chơi chiến lược với Tây Ban Nha. Trò chơi của bạn có trạng thái: mọi người có lãnh thổ nào, mọi người có bao nhiêu tài nguyên, liên minh nào tồn tại và với ai, ai đang có chiến tranh, v.v. Thông tin này, trạng thái chương trình của chúng tôi, bằng cách nào đó phải được lưu lại để khôi phục dữ liệu và tiếp tục trò chơi. Khi nó xảy ra, <strong>Tuần tự hóa trong Java</strong> là quá trình lưu trạng thái của một đối tượng dưới dạng một chuỗi byte. <strong>Deserialization trong Java</strong> là quá trình khôi phục một đối tượng từ các byte này. Bất kỳ đối tượng Java nào cũng có thể được chuyển đổi thành chuỗi byte. Tại sao chúng ta cần điều này? Chúng tôi đã nhiều lần nói rằng các chương trình không tự tồn tại. Thông thường, chúng tương tác với nhau, trao đổi dữ liệu, v.v. Định dạng byte thuận tiện và hiệu quả cho việc này. Ví dụ: chúng tôi có thể chuyển đổi một đối tượng của <span class="code">Trò chơi đã lưu của chúng tôi</span>thành một chuỗi các byte, chuyển các byte này qua mạng sang một máy tính khác, sau đó trên máy tính kia chuyển đổi các byte này trở lại thành một đối tượng Java! Nghe có vẻ khó nhỉ? Có vẻ như khó có thể làm nên chuyện này :/ Mừng là không phải vậy! :) Trong Java, giao diện <span class="code">Serializable</span> chịu trách nhiệm cho quá trình tuần tự hóa. Giao diện này cực kỳ đơn giản: Bạn không cần phải triển khai một phương thức duy nhất để sử dụng nó! Hãy xem lớp của chúng ta lưu trò chơi đơn giản như thế nào:</p><pre class="line-numbers language-java" tabindex="0"><code>import java.io.Serializable;
import java.util.Arrays;

public class SavedGame implements Serializable {

   private static final long serialVersionUID = 1L;

   private String[] territoryInfo;
   private String[] resourceInfo;
   private String[] diplomacyInfo;

   public SavedGame(String[] territoryInfo, String[] resourceInfo, String[] diplomacyInfo){
       this.territoryInfo = territoryInfo;
       this.resourceInfo = resourceInfo;
       this.diplomacyInfo = diplomacyInfo;
   }

   public String[] getTerritoryInfo() {
       return territoryInfo;
   }

   public void setTerritoryInfo(String[] territoryInfo) {
       this.territoryInfo = territoryInfo;
   }

   public String[] getResourceInfo() {
       return resourceInfo;
   }

   public void setResourceInfo(String[] resourceInfo) {
       this.resourceInfo = resourceInfo;
   }

   public String[] getDiplomacyInfo() {
       return diplomacyInfo;
   }

   public void setDiplomacyInfo(String[] diplomacyInfo) {
       this.diplomacyInfo = diplomacyInfo;
   }

   @Override
   public String toString() {
       return "SavedGame{" +
               "territoryInfo=" + Arrays.toString(territoryInfo) +
               ", resourceInfo=" + Arrays.toString(resourceInfo) +
               ", diplomacyInfo=" + Arrays.toString(diplomacyInfo) +
               '}';
   }
}</code></pre><p>Ba mảng chịu trách nhiệm cung cấp thông tin về lãnh thổ, tài nguyên và ngoại giao, và giao diện Serializable cho máy Java biết: ' <em>mọi thứ đều ổn nếu các đối tượng của lớp này có thể được tuần tự hóa</em> '.' Một giao diện không có giao diện duy nhất trông kỳ lạ :/ Tại sao lại cần thiết? Câu trả lời cho câu hỏi đó đã được đưa ra ở trên: chỉ cần cung cấp thông tin cần thiết cho máy Java. Trong một bài học trước, chúng tôi đã đề cập ngắn gọn về giao diện đánh dấu. Đây là những giao diện thông tin đặc biệt chỉ đơn giản đánh dấu các lớp của chúng tôi bằng thông tin bổ sung sẽ hữu ích cho máy Java trong tương lai. Họ không có bất kỳ phương pháp nào mà bạn phải thực hiện. Đây là <span class="code">Serializable</span> — một giao diện như vậy. Đây là một điểm quan trọng khác: Tại sao chúng ta cần<span class="code">Biến serialVersionUID dài cuối cùng tĩnh riêng tư</span> mà chúng ta đã định nghĩa trong lớp? Trường này chứa mã định danh phiên bản duy nhất của lớp được xê-ri hóa. Mỗi lớp thực hiện giao diện <span class="code">Nối tiếp</span> có một mã định danh phiên bản. Nó được xác định dựa trên nội dung của lớp — các trường và thứ tự khai báo của chúng, các phương thức và thứ tự khai báo của chúng. Và nếu chúng ta thay đổi loại trường và/hoặc số lượng trường trong lớp của mình, thì mã định danh phiên bản sẽ thay đổi ngay lập tức. serialVersionUID cũng được viết khi lớp được tuần tự hóa <span class="code">. </span>Khi chúng tôi cố gắng giải tuần tự hóa, tức là khôi phục một đối tượng từ chuỗi byte, giá trị của <span class="code">serialVersionUID</span> được so sánh với giá trị của <span class="code">serialVersionUID</span>của lớp trong chương trình của chúng tôi. Nếu các giá trị không khớp, thì java.io.InvalidClassException sẽ bị ném ra. Chúng ta sẽ thấy một ví dụ về điều này dưới đây. Để tránh những tình huống như vậy, chúng tôi chỉ cần đặt số nhận dạng phiên bản cho lớp của mình theo cách thủ công. Trong trường hợp của chúng tôi, nó sẽ đơn giản bằng 1 (bạn có thể sử dụng bất kỳ số nào khác mà bạn thích). Chà, đã đến lúc thử tuần tự hóa đối tượng <span class="code">SavingGame</span> của chúng ta và xem điều gì sẽ xảy ra!</p><pre class="line-numbers language-java" tabindex="0"><code>import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;

public class Main {

   public static void main(String[] args) throws IOException {

       
       String[] territoryInfo = {"Spain has 6 provinces", "Russia has 10 provinces", "France has 8 provinces"};
       String[] resourceInfo = {"Spain has 100 gold", "Russia has 80 gold", "France has 90 gold"};
       String[] diplomacyInfo = {"France is at war with Russia, Spain has taken a neutral position"};

       SavedGame savedGame = new SavedGame(territoryInfo, resourceInfo, diplomacyInfo);

       
       FileOutputStream outputStream = new FileOutputStream("C:\\Users\\Username\\Desktop\\save.ser");
       ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);

       
       objectOutputStream.writeObject(savedGame);

       
       objectOutputStream.close();
   }
}</code></pre><p>Như bạn có thể thấy, chúng tôi đã tạo 2 luồng: <span class="code">FileOutputStream</span> và <span class="code">ObjectOutputStream</span> . Cái đầu tiên biết cách ghi dữ liệu vào tệp và cái thứ hai chuyển đổi các đối tượng thành byte. Bạn đã thấy các cấu trúc lồng nhau tương tự, ví dụ: <span class="code">new BufferedReader(new InputStreamReader(...))</span> , trong các bài học trước, vì vậy chúng sẽ không làm bạn sợ :) Bằng cách tạo chuỗi hai luồng này, chúng ta thực hiện cả hai tác vụ: chúng tôi chuyển đổi đối tượng <span class="code">SavingGame</span> thành một chuỗi byte và lưu nó vào một tệp bằng phương thức <span class="code">writeObject()</span> . Và, nhân tiện, chúng tôi thậm chí còn không nhìn vào những gì chúng tôi có! Đã đến lúc xem hồ sơ! <em>*Lưu ý: không cần tạo file trước. Nếu một tệp có tên được chỉ định không tồn tại, thì nó sẽ được tạo tự động*</em> Và đây là nội dung của nó: <em>¬н sr SavingGame [ngoại giaoInfot [Ljava/lang/String;[ resourceInfoq ~ [ lãnh thổInfoq ~ xpur [Ljava.lang. String;¬ТVзй{G xp t pР¤СЂР°РЅС†РёСЏ РІРѕСЋРµС‚ СЃ Р РѕСЃСЃРёРµР№, Р˜СЃРїР°РЅР ёСЏ Р·Р°РЅСЏР»Р° РїРѕР·РёС†РёСЋ РЅРµР№С‚СЂР°Р»РёС‚ РµС‚Р°uq ~ t "РЈ Р˜СЃРїР°РЅРёРё 100 Р·РѕР»РѕС‚Р°t РЈ Р РѕСЃСЃРёРё 80 Р·РѕР»Р ѕС‚Р°t !РЈ Р¤СЂР°РЅС†РёРё 90 Р·РѕР »РѕС‚Р°uq ~ t &amp;РЈ Р˜СЃРїР°РЅРёРё 6 РїСЂРѕРІРёРЅС†РёР№t %РЈ Р РѕСЃСЃРёРё 10 Người chơi</em> Ồ, ồ :( Có vẻ như chương trình của chúng tôi không hoạt động : ( Thực ra, nó đã hoạt động. Bạn có nhớ rằng chúng tôi đã gửi một chuỗi byte, chứ không chỉ đơn giản là một đối tượng hoặc văn bản, tới tệp không? Chà, đây là chuỗi byte này trông giống như vậy :) Đó là trò chơi đã lưu của chúng ta! Nếu chúng ta muốn khôi phục đối tượng ban đầu của mình, tức là bắt đầu và tiếp tục trò chơi mà chúng ta đã dừng lại, thì chúng ta cần quy trình ngược lại: deserialization. Đây là giao diện của chúng ta:</p><pre class="line-numbers language-java" tabindex="0"><code>import java.io.*;

public class Main {

   public static void main(String[] args) throws IOException, ClassNotFoundException {

       FileInputStream fileInputStream = new FileInputStream("C:\\Users\\Username\\Desktop\\save.ser");
       ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);

       SavedGame savedGame = (SavedGame) objectInputStream.readObject();

       System.out.println(savedGame);
   }
}</code></pre><p>Và đây là kết quả! <em>Đã lưuGame{territoryInfo=[Tây Ban Nha có 6 tỉnh, Nga có 10 tỉnh, Pháp có 8 tỉnh], resourceInfo=[Tây Ban Nha có 100 vàng, Nga có 80 vàng, Pháp có 90 vàng],ngoại giaoInfo=[Pháp đang có chiến tranh với Nga, Tây Ban Nha đã giữ vị trí trung lập]}</em> Xuất sắc! Trước tiên, chúng tôi đã cố gắng lưu trạng thái trò chơi của mình vào một tệp, sau đó khôi phục trạng thái trò chơi đó từ tệp. Bây giờ, hãy thử làm điều tương tự, nhưng chúng tôi sẽ xóa mã định danh phiên bản khỏi lớp <span class="code">Trò chơi đã lưu</span> của chúng tôi . Chúng tôi sẽ không viết lại cả hai lớp học của chúng tôi. Mã của họ sẽ giống nhau. Chúng tôi sẽ chỉ xóa <span class="code">private static serialVersionUID cuối cùng</span> khỏi lớp <span class="code">SavingGame</span> . Đây là đối tượng của chúng tôi sau khi tuần tự hóa: <em>¬н sr Đã lưuGameі€MіuОm‰ [ ngoại giaoInfot [Ljava/lang/String;[ resourceInfoq ~ [ TerritoryInfoq ~ xpur [Ljava.lang.String;¬ТVзй{G xp t pР¤СЂР°РЅС†РёСЏ РІРѕСЋРµС‚ С Ѓ Р РѕСЃСЃРёРµР№, Р˜СЃРїР°РЅРёСЏ Р·Р°РЅСЏР»Р° РїРѕР·РёС†РёСЋ РЅРµР№С‚СЂР°Р»РёС‚РµС ‚Р°uq ~ t "РЈ Р˜СЃРїР°РЅРёРё 100 Р·РѕР»РѕС‚Р °t РЈ Р РѕСЃСЃРёРё 80 Р·РѕР»РѕС‚Р°t !РЈ Р¤СЂР°РЅС†РёРё 90 Р·РѕР»РѕС‚Р°uq ~ t &amp;РЈ Р˜СЃРїР°РЅРёРё 6 РїСЂРѕРІРёРЅС†РёР№t %РЈ Р РѕСЃСЃРёРё 10 РїСЂРѕРІРёРЅС†РёР№t &amp;РЈ Р¤СЂР°РЅС†РёРё 8 РїСЂРѕРІР ёРЅС†РёР№</em> Nhưng hãy xem điều gì xảy ra khi chúng ta cố gắng giải tuần tự hóa nó: <em>InvalidClassException: lớp cục bộ không tương thích: luồng classdesc serialVersionUID = -196410440475012755, lớp cục bộ serialVersionUID = -6675950253085108747</em> Nhân tiện, chúng tôi đã bỏ lỡ một điều quan trọng. Rõ ràng, các chuỗi và nguyên thủy được sắp xếp theo thứ tự một cách dễ dàng: Java chắc chắn có một số cơ chế tích hợp sẵn cho việc này. Nhưng nếu lớp <span class="code">có thể tuần tự hóa</span> của chúng ta có các trường không phải là nguyên thủy, mà là tham chiếu đến các đối tượng khác thì sao? Ví dụ: hãy tạo lớp <span class="code">TerritoryInfo</span> , <span class="code">ResourceInfo</span> và <span class="code">DiplomacyInfo</span> riêng biệt để làm việc với lớp <span class="code">SavingGame</span> của chúng ta .</p><pre class="line-numbers language-java" tabindex="0"><code>public class TerritoryInfo {

   private String info;

   public TerritoryInfo(String info) {
       this.info = info;
   }

   public String getInfo() {
       return info;
   }

   public void setInfo(String info) {
       this.info = info;
   }

   @Override
   public String toString() {
       return "TerritoryInfo{" +
               "info='" + info + '\'' +
               '}';
   }
}

public class ResourceInfo {

   private String info;

   public ResourceInfo(String info) {
       this.info = info;
   }

   public String getInfo() {
       return info;
   }

   public void setInfo(String info) {
       this.info = info;
   }

   @Override
   public String toString() {
       return "ResourceInfo{" +
               "info='" + info + '\'' +
               '}';
   }
}

public class DiplomacyInfo {

   private String info;

   public DiplomacyInfo(String info) {
       this.info = info;
   }

   public String getInfo() {
       return info;
   }

   public void setInfo(String info) {
       this.info = info;
   }

   @Override
   public String toString() {
       return "DiplomacyInfo{" +
               "info='" + info + '\'' +
               '}';
   }
}</code></pre><p>Và bây giờ chúng ta phải đối mặt với một câu hỏi: Tất cả các lớp này có phải là <span class="code">Có thể tuần tự hóa</span> nếu chúng ta muốn tuần tự hóa lớp <span class="code">SavingGame</span> của mình không ?</p><pre class="line-numbers language-java" tabindex="0"><code>import java.io.Serializable;
import java.util.Arrays;

public class SavedGame implements Serializable {

   private TerritoryInfo territoryInfo;
   private ResourceInfo resourceInfo;
   private DiplomacyInfo diplomacyInfo;

   public SavedGame(TerritoryInfo territoryInfo, ResourceInfo resourceInfo, DiplomacyInfo diplomacyInfo) {
       this.territoryInfo = territoryInfo;
       this.resourceInfo = resourceInfo;
       this.diplomacyInfo = diplomacyInfo;
   }

   public TerritoryInfo getTerritoryInfo() {
       return territoryInfo;
   }

   public void setTerritoryInfo(TerritoryInfo territoryInfo) {
       this.territoryInfo = territoryInfo;
   }

   public ResourceInfo getResourceInfo() {
       return resourceInfo;
   }

   public void setResourceInfo(ResourceInfo resourceInfo) {
       this.resourceInfo = resourceInfo;
   }

   public DiplomacyInfo getDiplomacyInfo() {
       return diplomacyInfo;
   }

   public void setDiplomacyInfo(DiplomacyInfo diplomacyInfo) {
       this.diplomacyInfo = diplomacyInfo;
   }

   @Override
   public String toString() {
       return "SavedGame{" +
               "territoryInfo=" + territoryInfo +
               ", resourceInfo=" + resourceInfo +
               ", diplomacyInfo=" + diplomacyInfo +
               '}';
   }
}</code></pre><p>Thôi được! Hãy thử nghiệm nó! Hiện tại, chúng tôi sẽ để nguyên mọi thứ và cố gắng tuần tự hóa một đối tượng <span class="code">SavingGame</span> :</p><pre class="line-numbers language-java" tabindex="0"><code>import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;

public class Main {

   public static void main(String[] args) throws IOException {

       
       TerritoryInfo territoryInfo = new TerritoryInfo("Spain has 6 provinces, Russia has 10 provinces, France has 8 provinces");
       ResourceInfo resourceInfo = new ResourceInfo("Spain has 100 gold, Russia has 80 gold, France has 90 gold");
       DiplomacyInfo diplomacyInfo =  new DiplomacyInfo("France is at war with Russia, Spain has taken a neutral position");


       SavedGame savedGame = new SavedGame(territoryInfo, resourceInfo, diplomacyInfo);

       FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\Username\\Desktop\\save.ser");
       ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);

       objectOutputStream.writeObject(savedGame);

       objectOutputStream.close();
   }
}</code></pre><p>Kết quả: <em>Ngoại lệ trong luồng "chính" java.io.NotSerializableException: DiplomacyInfo</em> Nó không hoạt động! Vì vậy, đây là câu trả lời cho câu hỏi của chúng tôi. Khi một đối tượng được tuần tự hóa, tất cả các đối tượng được tham chiếu bởi các biến đối tượng của nó đều được tuần tự hóa. Và nếu các đối tượng đó cũng tham chiếu đến các đối tượng khác, thì chúng cũng được tuần tự hóa. Và cứ thế mãi mãi. Tất cả các lớp trong chuỗi này phải được <span class="code">tuần tự hóa</span> , nếu không sẽ không thể tuần tự hóa chúng và một ngoại lệ sẽ được đưa ra. Nhân tiện, điều này có thể tạo ra vấn đề trong quá trình thực hiện. Ví dụ, chúng ta nên làm gì nếu chúng ta không cần một phần của lớp trong quá trình tuần tự hóa? Hoặc điều gì sẽ xảy ra nếu chúng ta có lớp <span class="code">TerritoryInfo</span> 'thông qua kế thừa' như một phần của thư viện? Và giả sử xa hơn rằng nó không phải làvà theo đó, chúng ta không thể thay đổi nó. Điều đó có nghĩa là chúng ta không thể thêm trường <span class="code">TerritoryInfo</span> vào lớp <span class="code">Trò chơi đã lưu</span> của mình , bởi vì khi đó toàn bộ lớp <span class="code">Trò chơi đã lưu</span> sẽ trở nên không thể sắp xếp được! Đó là một vấn đề: / <img loading="lazy" src="https://cdn.codegym.cc/images/article/1d7a483d-39da-4c1b-aa2c-a95877c70541/800.jpeg" alt="Tuần tự hóa và giải tuần tự hóa trong Java - 2" data-id="1d7a483d-39da-4c1b-aa2c-a95877c70541" data-max-width="850" data-is-external-image="true">Trong Java, loại vấn đề này được giải quyết bằng từ khóa <span class="code">thoáng qua</span> . Nếu bạn thêm từ khóa này vào một trường trong lớp của mình, thì trường đó sẽ không được đánh số thứ tự. Hãy thử đặt một trong các trường của lớp <span class="code">SavingGame của chúng ta </span><span class="code">thành tạm thời</span> , sau đó chúng ta sẽ sắp xếp theo thứ tự và khôi phục một đối tượng.</p><pre class="line-numbers language-java" tabindex="0"><code>import java.io.Serializable;

public class SavedGame implements Serializable {

   private transient TerritoryInfo territoryInfo;
   private ResourceInfo resourceInfo;
   private DiplomacyInfo diplomacyInfo;

   public SavedGame(TerritoryInfo territoryInfo, ResourceInfo resourceInfo, DiplomacyInfo diplomacyInfo) {
       this.territoryInfo = territoryInfo;
       this.resourceInfo = resourceInfo;
       this.diplomacyInfo = diplomacyInfo;
   }

   
}



import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;

public class Main {

   public static void main(String[] args) throws IOException {

       
       TerritoryInfo territoryInfo = new TerritoryInfo("Spain has 6 provinces, Russia has 10 provinces, France has 8 provinces");
       ResourceInfo resourceInfo = new ResourceInfo("Spain has 100 gold, Russia has 80 gold, France has 90 gold");
       DiplomacyInfo diplomacyInfo =  new DiplomacyInfo("France is at war with Russia, Spain has taken a neutral position");


       SavedGame savedGame = new SavedGame(territoryInfo, resourceInfo, diplomacyInfo);

       FileOutputStream fileOutputStream = new FileOutputStream("C:\\Users\\Username\\Desktop\\save.ser");
       ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);

       objectOutputStream.writeObject(savedGame);

       objectOutputStream.close();
   }
}


import java.io.*;

public class Main {

   public static void main(String[] args) throws IOException, ClassNotFoundException {

       FileInputStream fileInputStream = new FileInputStream("C:\\Users\\Username\\Desktop\\save.ser");
       ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);

       SavedGame savedGame = (SavedGame) objectInputStream.readObject();

       System.out.println(savedGame);

       objectInputStream.close();


   }
}</code></pre><p>Và đây là kết quả: <em>SavingGame{territoryInfo=null, resourceInfo=ResourceInfo{info='Tây Ban Nha có 100 vàng, Nga có 80 vàng, Pháp có 90 vàng'},ngoại giaoInfo=DiplomacyInfo{info='Pháp đang có chiến tranh với Nga, Tây Ban Nha đã giữ vị trí trung lập'}}</em> Như đã nói, chúng ta đã có câu trả lời cho câu hỏi giá trị nào sẽ được gán cho trường <span class="code">tạm thời</span> . Nó được gán giá trị mặc định. Đối với các đối tượng, đây là <span class="code">null</span> . Bạn có thể đọc một chương hay về chủ đề này trong cuốn sách 'Head-First Java', Hãy chú ý đến nó :) </p></div><footer class="content__footer"><div class="entry-wrapper"><p class="content__updated">This article was updated on December 27, 2024</p><div class="content__actions"><div class="content__share"><button class="btn--icon content__share-button js-content__share-button"><svg width="20" height="20" aria-hidden="true"><use xlink:href="https://github.com/HuyPhuongVN/PhuongBlog.git/assets/svg/svg-map.svg#share"></use></svg> <span>Share It</span></button><div class="content__share-popup js-content__share-popup"></div></div></div><div class="content__bio bio"><div><h3 class="h4 bio__name"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/rainblog/huyphuong/" rel="author">Trần Huy Phương</a></h3></div></div></div><nav class="content__nav"><div class="wrapper"><div class="content__nav-inner"><div class="content__nav-prev"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-5-lap-trinh-socket-cho-giao-thuc-tcp/" class="content__nav-link" rel="prev"><div><span>Previous</span> Chương 5: Lập trình socket cho giao thức TCP</div></a></div><div class="content__nav-next"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-7-lap-trinh-socket-cho-giao-thuc-udp/" class="content__nav-link" rel="next"><div><span>Next</span> Chương 7: Lập trình socket cho giao thức UDP</div></a></div></div></div></nav></footer></article><div class="content__related related"><div class="wrapper"><h2 class="h4 related__title">You should also read:</h2><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/rainblog/huyphuong/" class="feed__author">Trần Huy Phương</a> <time datetime="2024-12-27T19:35" class="feed__date">December 27, 2024</time></div><h3 class="feed__title"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-7-lap-trinh-socket-cho-giao-thuc-udp/">Chương 7: Lập trình socket cho giao thức UDP</a></h3></header><p>1. Lập tình socket với UDP Đầu tiên, UDP là viết tắt của User Datagram Protocol. UDP được giới thiệu vào năm 1980 và là một trong những giao thức mạng lâu đời nhất còn được sử dụng. UDP được sử dụng cho những đường&hellip;</p><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-7-lap-trinh-socket-cho-giao-thuc-udp/" class="readmore feed__readmore">Continue reading...</a></div></article><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/rainblog/huyphuong/" class="feed__author">Trần Huy Phương</a> <time datetime="2024-12-27T19:32" class="feed__date">December 27, 2024</time></div><h3 class="feed__title"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-5-lap-trinh-socket-cho-giao-thuc-tcp/">Chương 5: Lập trình socket cho giao thức TCP</a></h3></header><p>Socket được biết đến là cánh cửa giao tiếp giữa hai tiến trình ứng dụng. Socket hỗ trợ nhiều ngôn ngữ (C, java, perl, python,…) cũng như nhiều platform (*nix, Windows,…). Socket được viết bằng các ngôn ngữ khác nhau và chạy trên bất kỳ&hellip;</p><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-5-lap-trinh-socket-cho-giao-thuc-tcp/" class="readmore feed__readmore">Continue reading...</a></div></article><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/rainblog/huyphuong/" class="feed__author">Trần Huy Phương</a> <time datetime="2024-12-27T19:29" class="feed__date">December 27, 2024</time></div><h3 class="feed__title"><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-4-quan-ly-dia-chi-ket-noi-mang/">Chương 4: Quản lý địa chỉ kết nối mạng</a></h3></header><p>Giới thiệu Trong lập trình Java, việc làm việc với địa chỉ mạng và URL rất quan trọng, đặc biệt khi xây dựng các ứng dụng mạng hoặc web. Java cung cấp hai lớp mạnh mẽ là InetAddress và URL trong gói java.net để hỗ&hellip;</p><a href="https://github.com/HuyPhuongVN/PhuongBlog.git/posts/chuong-4-quan-ly-dia-chi-ket-noi-mang/" class="readmore feed__readmore">Continue reading...</a></div></article></div></div></main><footer class="footer footer--glued"><div class="wrapper"><div class="footer__copyright"><p>Powered by Publii</p></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://github.com/HuyPhuongVN/PhuongBlog.git/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://github.com/HuyPhuongVN/PhuongBlog.git/assets/js/scripts.min.js?v=700105c316933a8202041b6415abb233"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>